package com.xcrj.offersa.pass1;

/**
 * 剑指 Offer II 092. 翻转字符
 * 如果一个由'0' 和 '1'组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。
 * 我们给出一个由字符 '0' 和 '1' 组成的字符串 s，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。
 * 返回使 s 单调递增 的最小翻转次数。
 */
public class Solution92 {
    /**
     * dp[i][0]和dp[i][1]分别记录“将第i项翻转为0所需要的翻转次数”和“将第i项翻转为1所需要的翻转次数”，最后结果为min{dp[n-1][0],dp[n-1][0]}
     * - 求整个字符串保证递增所需的最小翻转次数，可以看成前缀串保证递增所需的最小翻转次数
     * - 第i项可能为0，也可能为1，使用dp[i][0],dp[i][1]分别记录
     *
     * 动态规划+滚动数组
     * 动态规划：将多阶段过程转换为单阶段问题，将单阶段问题的解存储在动态规划数组中
     * <p>
     * 单调递增的字符串满足以下性质：
     * - 首个字符是0或1；
     * - 其余的每个字符，字符0前面的相邻字符一定是0，字符1前面的相邻字符可以是0或1。
     * <p>
     * dp[i][0]和dp[i][1]分别表示“将第i项翻转为0所需要的翻转次数”和“将第i项翻转为1所需要的翻转次数”。
     * - 当i=0时，一定满足单调递增，因此dp[0][0]和dp[0][1]的值取决于字符s[i]。具体而言dp[0][0]=I(s[0]='1')，dp[0][1]=I(s[0]='0')，其中I为示性函数，当事件成立时示性函数值为1，当事件不成立时示性函数值为0。
     * - 当1<=i<n时，考虑下标i处的字符。如果下标i处的字符是0，则只有当下标i−1处的字符是0时才符合单调递增；如果下标i处的字符是1，则下标i−1处的字符是0或1 都符合单调递增，此时为了将翻转次数最小化，应分别考虑下标i−1 处的字符是0和1的情况下需要的翻转次数，取两者的最小值。
     * <p>
     * 动态规划数组，状态转移方程
     * - 将第i项翻转为0所需要的翻转次数，dp[i][0]=dp[i−1][0]+I(s[i]='1')，将第i项翻转为0所需要的翻转次数取决于“将前一项翻转为0的翻转次数和当前项是否为1”
     * - 将第i项翻转为1所需要的翻转次数，dp[i][1]=min(dp[i−1][0],dp[i−1][1])+I(s[i]='0')，将第i项翻转为1所需要的翻转次数取决于“min{将前一项翻转为0的翻转次数,将前一项翻转为1的翻转次数}+当前项是否为0”
     * <p>
     * 优化
     * - 将边界情况定义为dp[−1][0]=dp[−1][1]=0，则可以从下标0开始使用状态转移方程计算状态值。
     * - 由于dp[i]的值只和dp[i−1]有关，因此在计算状态值的过程中只需要维护前一个下标处的状态值，将空间复杂度降低到 O(1)O(1)。
     */
    public int minFlipsMonoIncr(String s) {
        // 将边界情况定义为dp[−1][0]=dp[−1][1]=0，则可以从下标0开始使用状态转移方程计算状态值。
        int dp0 = 0, dp1 = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int dpNew0 = dp0;
            int dpNew1 = Math.min(dp0, dp1);
            // dp[i][0]=dp[i−1][0]+I(s[i]='1')
            // dp[i][1]=min(dp[i−1][0],dp[i−1][1])+I(s[i]='0')
            if (c == '1') {
                dpNew0++;
            } else {
                dpNew1++;
            }
            dp0 = dpNew0;
            dp1 = dpNew1;
        }

        return Math.min(dp0, dp1);
    }
}
